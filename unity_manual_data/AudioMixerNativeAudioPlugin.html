<!DOCTYPE html><html lang="en" class="no-js">
<head>
<meta content="text/html; charset=UTF-8" http-equiv="Content-Type">
<script type="text/javascript" src="https://cdn.cookielaw.org/scripttemplates/otSDKStub.js" charset="UTF-8" data-domain-script="6e91be4c-3145-4ea2-aa64-89d716064836"></script><script type="text/javascript">
					function OptanonWrapper() { }
				</script><script>var offline=(location.href.indexOf('docs.unity3d.com')==-1)?true:false;if(!offline){(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':  new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0], j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=   'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);  })(window,document,'script','dataLayer','GTM-5V25JL6');}</script><link href="https://fonts.googleapis.com/css?family=Roboto&amp;display=swap" rel="stylesheet">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Unity - Manual:  Native audio plug-in SDK</title>
<meta property="og:image" content="https://unity3d.com/files/images/ogimg.jpg">
<meta name="author" content="Unity Technologies">
<link rel="shortcut icon" href="https://unity.com/themes/contrib/unity_base/images/favicons/favicon.ico">
<link rel="icon" type="image/png" href="../StaticFilesManual/images/favicons/favicon.png">
<link rel="apple-touch-icon-precomposed" sizes="152x152" href="../StaticFilesManual/images/favicons/apple-touch-icon-152x152.png">
<link rel="apple-touch-icon-precomposed" sizes="144x144" href="../StaticFilesManual/images/favicons/apple-touch-icon-144x144.png">
<link rel="apple-touch-icon-precomposed" sizes="120x120" href="../StaticFilesManual/images/favicons/apple-touch-icon-120x120.png">
<link rel="apple-touch-icon-precomposed" sizes="114x114" href="../StaticFilesManual/images/favicons/apple-touch-icon-114x114.png">
<link rel="apple-touch-icon-precomposed" sizes="72x72" href="../StaticFilesManual/images/favicons/apple-touch-icon-72x72.png">
<link rel="apple-touch-icon-precomposed" href="../StaticFilesManual/images/favicons/apple-touch-icon.png">
<meta name="msapplication-TileColor" content="#222c37">
<meta name="msapplication-TileImage" content="../StaticFilesManual/images/favicons/tileicon-144x144.png">
<script type="text/javascript" src="https://docs.unity3d.com/StaticFilesConfig/UnityVersionsInfo.js"></script><script type="text/javascript" src="../StaticFilesManual/js/jquery.js?ts=20230925"></script><script type="text/javascript" src="../StaticFilesManual/js/core.js?ts=20230925"></script><script type="text/javascript" src="docdata/toc.js?ts=20230925"></script><script type="text/javascript" src="docdata/global_toc.js?ts=20230925"></script><link rel="stylesheet" type="text/css" href="../StaticFilesManual/css/core.css?ts=20230925">
<link rel="stylesheet" href="../StaticFilesManual/css/prism.css">
<script src="../StaticFilesManual/js/prism.js"></script><script src="/StaticFilesConfig/feedback/feedback.js"></script><script src="../StaticFilesManual/js/jquery.sidebar.min.js"></script><link rel="stylesheet" href="../StaticFilesManual/css/mobileoptimisation.css">
<script src="../StaticFilesManual/js/mobileoptimisation.js"></script>
</head>
<body>
<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-5V25JL6" height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
<div id="DocsAnalyticsData" data-area="authoring" data-pagetype="manual"></div>
<div class="header-wrapper">
<div id="header" class="header"><div class="content">
<div class="spacer"><div class="menu">
<div id="nav-open" for="nav-input"><span></span></div>
<div class="logo"><a href="https://docs.unity3d.com"></a></div>
<div class="search-form"><form action="30_search.html" method="get" class="apisearch">
<input type="text" name="q" placeholder="Search manual..." autosave="Unity Reference" results="5" class="sbox field" id="q"><input type="submit" class="submit">
</form></div>
<ul>
<li><a href="../Manual/index.html" class="selected">Manual</a></li>
<li><a href="../ScriptReference/index.html">Scripting API</a></li>
</ul>
</div></div>
<div class="more">
<div class="filler"></div>
<ul><li><a href="https://unity.com/">unity.com</a></li></ul>
</div>
</div></div>
<div class="toolbar"><div class="content">
<div class="toggle version-number" id="VersionNumber" data-target=".otherversionscontent">
                                Version: <b>2023.1</b><div class="otherversionscontent" id="OtherVersionsContent" style="display: none;">
<ul id="OtherVersionsContentUl"></ul>
<div id="otherVersionsLegend"><ul>
<li>
<div id="supportedColour" class="legendBox"></div>Supported</li>
<li>
<div id="notFoundColour" class="legendBox"></div>Legacy</li>
</ul></div>
</div>
<div id="VersionSwitcherArrow" class="arrow versionSwitcherArrow"></div>
</div>
<div class="lang-switcher"><div class="current toggle" data-target=".lang-list">
<div class="lbl">Language
:                <span class="b">English</span>
</div>
<div class="arrow"></div>
<div class="lang-list" style="display:none;"><ul>
<li><a href="/Manual/AudioMixerNativeAudioPlugin.html">English</a></li>
<li><a href="/cn/current/Manual/AudioMixerNativeAudioPlugin.html">中文</a></li>
<li><a href="/ja/current/Manual/AudioMixerNativeAudioPlugin.html">日本語</a></li>
<li><a href="/kr/current/Manual/AudioMixerNativeAudioPlugin.html">한국어</a></li>
</ul></div>
</div></div>
</div></div>
<div class="mobileLogo"><a href="https://docs.unity3d.com"></a></div>
</div>
<div id="master-wrapper" class="master-wrapper clear">
<div id="sidebar" class="sidebar"><div class="sidebar-wrap"><div class="content"><div class="sidebar-menu"><div class="toc" id="customScrollbar">
<h2>Unity Manual</h2>
<div class="search-form sidebar-search-form"><form action="30_search.html" method="get" class="apisearch">
<input type="text" name="q" placeholder="Search manual..." autosave="Unity Reference" results="5" class="sbox field" id="q"><input type="submit" id="mobileSearchBtn" class="submit" value="Search">
</form></div>
<div class="toggle version-number sidebar-version-switcher" id="VersionNumber" data-target=".otherversionscontent"><form id="otherVersionsContentMobileForm"><div class="ui-field-contain">
<label for="select-native-4">Version: 2023.1</label><select name="select-native-4" id="versionsSelectMobile"><option>Select a different version</option>
<optgroup id="versionsWithThisPageMobile" label="Versions with this page"></optgroup>
<optgroup id="versionsWithoutThisPageMobile" label="Versions without this page"></optgroup></select>
</div></form></div>
<div class="lang-switcher"><div class="current toggle" data-target=".lang-list">
<div class="lbl">Language
:                <span class="b">English</span>
</div>
<div class="arrow"></div>
<div class="lang-list" style="display:none;"><ul>
<li><a href="/Manual/AudioMixerNativeAudioPlugin.html">English</a></li>
<li><a href="/cn/current/Manual/AudioMixerNativeAudioPlugin.html">中文</a></li>
<li><a href="/ja/current/Manual/AudioMixerNativeAudioPlugin.html">日本語</a></li>
<li><a href="/kr/current/Manual/AudioMixerNativeAudioPlugin.html">한국어</a></li>
</ul></div>
</div></div>
</div></div></div></div></div>
<div id="content-wrap" class="content-wrap"><div class="content-block"><div class="content">
<div class="section">
<div class="breadcrumbs clear"><ul>
<li><a href="UnityManual.html"> Unity User Manual 2023.1 </a></li>
<li><a href="Audio.html"> Audio</a></li>
<li> Native audio plug-in SDK</li>
</ul></div>
<div class="mb20"><div class="nextprev clear">
<div class="icon tt left mr1" data-distance="-40|-30|top">
<span class="prev"><a href="AudioMixerUsage.html"></a></span><div class="tip">Overview of Usage and API</div>
</div>
<div class="icon tt right" data-distance="-40|-30|top">
<span class="next"><a href="AudioSpatializerSDK.html"></a></span><div class="tip"> Audio Spatializer SDK</div>
</div>
</div></div>
<div id="_leavefeedback"></div>
<h1>Native audio plug-in SDK</h1>
<!--BeginSwitchLink--><!--EndSwitchLink-->
<div class="clear"></div>

<p>The native audio <span class="tooltip"><strong>plug-in</strong><span class="tooltiptext">A set of code created outside of Unity that creates functionality in Unity. There are two kinds of plug-ins you can use in Unity: Managed plug-ins (managed .NET assemblies created with tools like Visual Studio) and Native plug-ins (platform-specific native code libraries). <a class="tooltipMoreInfoLink" href="Plugins.html">More info</a><br/><span class="tooltipGlossaryLink">See in <a href="Glossary.html#Plug-in">Glossary</a></span></span></span> SDK is the built-in native audio plug-in interface of Unity. This page walks you through both basic concepts and complex use cases.</p>

<h2>Prerequisite</h2>

<p>You must first <a href="https://github.com/Unity-Technologies/NativeAudioPlugins">download the newest audio plug-in SDK</a>.</p>

<h2>Overview</h2>

<p>The native audio plug-in system consists of two parts:</p>

<ul>
<li><p>The native DSP (Digital Signal Processing) plug-in which should be implemented as a .dll (Windows) or .dylib (OSX) in C or C++. Unlike <span class="tooltip"><strong>scripts</strong><span class="tooltiptext">A piece of code that allows you to create your own Components, trigger game events, modify Component properties over time and respond to user input in any way you like. <a class="tooltipMoreInfoLink" href="CreatingAndUsingScripts.html">More info</a><br/><span class="tooltipGlossaryLink">See in <a href="Glossary.html#Scripts">Glossary</a></span></span></span>, this must be compilable by any platform that you want to support, possibly with platform-specific optimizations.</p></li>
<li><p>The GUI which is developed in C#. The GUI is optional, so you always start out plug-in development by creating the basic native DSP plug-in, and let Unity display a default slider-based <span class="tooltip"><strong>UI</strong><span class="tooltiptext">(User Interface) Allows a user to interact with your application. Unity currently supports three UI systems. <a class="tooltipMoreInfoLink" href="UI-system-compare.html">More info</a><br/><span class="tooltipGlossaryLink">See in <a class="tooltipMoreInfoLink" href="Glossary.html#UI">Glossary</a></span></span></span> for the parameter descriptions that the <span class="tooltip"><strong>native plug-in</strong><span class="tooltiptext">A platform-specific native code library that is created outside of Unity for use in Unity. Allows you can access features like OS calls and third-party code libraries that would otherwise not be available to Unity. <a href="Plugins.html">More info</a><br/><span class="tooltipGlossaryLink">See in <a href="Glossary.html#Nativeplug-in">Glossary</a></span></span></span> exposes. This is the recommended approach to initiate any project.</p></li>
</ul>

<p>You can initially prototype the C# GUI as a <code>.cs</code> file that you just drop into the Editor’s Assets folder much like any other Editor script. You can move this into a proper Visual Studio project later as your code starts to grow, and needs better modularization and better IDE support. This also enables you to compile it into a .dll, making it easier for the user to drop into the project and also to protect your code.</p>

<p>Both native DSP and GUI DLLs can contain multiple plug-ins, and binding happens only through the names of the effects in the plug-ins regardless of what the DLL file is called.</p>

<h2>File types</h2>

<p>The native side of the plug-in SDK consists of one file (<code>AudioPluginInterface.h</code>). However, to add multiple plug-in effects within the same <code>.dll</code>, Unity provides additional code to handle the effect definition and parameter registration in a unified manner (<code>AudioPluginUtil.h</code> and <code>AudioPluginUtil.cpp</code>). Note that the <code>NativePluginDemo</code> project contains several example plug-ins to get you started and display a variety of different plug-in types that are useful in a game context. This code is available in the public domain so anyone can use this code as a starting point to their own creations.</p>

<h2>Develop a plug-in</h2>

<p>To start developing a plug-in, define the parameters for your plug-in. Although, you don’t need to have a detailed plan of all the parameters that the plug-in should include, it’s useful to have a rough idea of the user experience and the various components to which you’d like to refer.</p>

<p>The example plug-ins that Unity provides come package with utility functions that’s easy to start with.
As an example, use the Ring Modulator example plug-in, which is a simple plug-in. It multiplies the incoming signal by a sine wave, which gives a nice radio-noise and broken reception like effect, especially if you chain together multiple ring modulation effects with different frequencies.</p>

<p>The basic scheme for dealing with parameters in the example plug-ins is to define them as enum-values that you use as indices into an array of floats for both convenience and brevity.</p>

<pre><code>enum Param
{
    P_FREQ,
    P_MIX,
    P_NUM
};

int InternalRegisterEffectDefinition(UnityAudioEffectDefinition&amp; definition)
{
    int numparams = P_NUM;
    definition.paramdefs = new UnityAudioParameterDefinition [numparams];
    RegisterParameter(definition, &quot;Frequency&quot;, &quot;Hz&quot;,
        0.0f, kMaxSampleRate, 1000.0f,
        1.0f, 3.0f,
        P_FREQ);
    RegisterParameter(definition, &quot;Mix amount&quot;, &quot;%&quot;,
        0.0f, 1.0f, 0.5f,
        100.0f, 1.0f,
        P_MIX);
    return numparams;
}
</code></pre>

<p>The numbers in the <code>RegisterParameter calls</code> are the minimum, maximum, and default values followed by a scaling factor used for display-only. That is, for a percentage-value, the actual value goes from 0 to 1 and can be scaled to 100 when displayed. Although, there is no custom GUI code for this, Unity will generate a default GUI from these basic parameter definitions. No checks are performed for undefined parameters, so the <code>AudioPluginUtil</code> system expects that all declared enum values (except <code>P_NUM</code>) are matched up with a corresponding parameter definition.</p>

<p>Behind the <span class="tooltip"><strong>scenes</strong><span class="tooltiptext">A Scene contains the environments and menus of your game. Think of each unique Scene file as a unique level. In each Scene, you place your environments, obstacles, and decorations, essentially designing and building your game in pieces. <a class="tooltipMoreInfoLink" href="CreatingScenes.html">More info</a><br/><span class="tooltipGlossaryLink">See in <a href="Glossary.html#Scene">Glossary</a></span></span></span> the RegisterParameter function fills out an entry in the UnityAudioParameterDefinition array of the UnityAudioEffectDefinition structure that’s associated with that plug-in (refer to the <code>AudioEffectPluginInterface.h</code> header file). In addition, set up the following remaining items in <code>UnityAudioEffectDefinition</code>:</p>

<ul>
<li>The callbacks to the functions that handle instantiating the plug-in (CreateCallback)</li>
<li>Set and get parameters for <code>SetFloatParameterCallback/UnityAudioEffect_GetFloatParameterCallback</code>
</li>
<li>The actual processing for <code>UnityAudioEffect_ProcessCallback</code>
</li>
<li>Destroy the plug-in instance for <code>UnityAudioEffect_ReleaseCallback</code> when done</li>
</ul>

<p>To make it easy to have multiple plug-ins in the same DLL, each plug-in resides in its own namespace, and a specific naming convention for the callback functions is used such that the <code>DEFINE_EFFECT</code> and <code>DECLARE_EFFECT</code> macros can fill out the UnityAudioEffectDefinition structure. Underneath the hood all the effects definitions are stored in an array to which a pointer is returned by the only entry point of the library UnityGetAudioEffectDefinitions.</p>

<p>This is useful to know in case you want to develop bridge plug-ins that map from other plug-in formats such as VST or AudioUnits to or from the Unity audio plug-in interface, in which case you need to develop a more dynamic way to set up the parameter descriptions at load time.</p>

<h3>Instantiating the plug-in</h3>

<p>You must next set the data for the instance of the plug-in. In the example plug-ins, data is set into the EffectData structure. The allocation of this must happen in the corresponding CreateCallback which is called for each instance of the plug-in in the mixer. Following is a simple example, where there’s only one sine-wave being multiplied to all channels. Typically, advanced plug-ins need you to allocate additional data per input channel.</p>

<pre><code>struct EffectData
{
    struct Data
    {
        float p[P_NUM]; // Parameters
        float s;        // Sine output of oscillator
        float c;        // Cosine output of oscillator
    };
    union
    {
        Data data;
        unsigned char pad[(sizeof(Data) + 15) &amp; ~15];
    };
};
</code></pre>

<pre><code>UNITY_AUDIODSP_RESULT UNITY_AUDIODSP_CALLBACK CreateCallback(
    UnityAudioEffectState* state)
{
    EffectData* effectdata = new EffectData;
    memset(effectdata, 0, sizeof(EffectData));
    effectdata-&gt;data.c = 1.0f;
    state-&gt;effectdata = effectdata;
    InitParametersFromDefinitions(
        InternalRegisterEffectDefinition, effectdata-&gt;data.p);
    return UNITY_AUDIODSP_OK;
}
</code></pre>

<p>The <code>UnityAudioEffectState</code> contains various data from the host such as the sampling rate, the total number of samples processed (for timing), or whether the plug-in is bypassed, and is passed to all callback functions.</p>

<p>To free the plug-in instance, use the following corresponding function:</p>

<pre><code>UNITY_AUDIODSP_RESULT UNITY_AUDIODSP_CALLBACK ReleaseCallback(
    UnityAudioEffectState* state)
{
    EffectData::Data* data = &amp;state-&gt;GetEffectData&lt;EffectData&gt;()-&gt;data;
    delete data;
    return UNITY_AUDIODSP_OK;
}
</code></pre>

<p>The main processing of audio happens in <code>ProcessCallback</code>:</p>

<pre><code>UNITY_AUDIODSP_RESULT UNITY_AUDIODSP_CALLBACK ProcessCallback(
    UnityAudioEffectState* state,
    float* inbuffer, float* outbuffer,
    unsigned int length,
    int inchannels, int outchannels)
{
    EffectData::Data* data = &amp;state-&gt;GetEffectData&lt;EffectData&gt;()-&gt;data;

    float w = 2.0f * sinf(kPI * data-&gt;p[P_FREQ] / state-&gt;samplerate);
    for(unsigned int n = 0; n &lt; length; n++)
    {
        for(int i = 0; i &lt; outchannels; i++)
        {
            outbuffer[n * outchannels + i] =
                inbuffer[n * outchannels + i] *
                (1.0f - data-&gt;p[P_MIX] + data-&gt;p[P_MIX] * data-&gt;s);
        }
        data-&gt;s += data-&gt;c * w; // cheap way to calculate a sine-wave
        data-&gt;c -= data-&gt;s * w;
    }

    return UNITY_AUDIODSP_OK;
}
</code></pre>

<p>The <code>GetEffectData</code> function at the top is a helper function casting the effectdata field of the state variable to the EffectData::Data in the structure that’s declared above.</p>

<p>Other simple plug-ins included are the NoiseBox plug-in, which adds and multiplies the input signal by white noise at variable frequencies, or the Lofinator plug-in, which does simple downsampling and quantization of the signal. All these can be used in combination and with game-driven animated parameters to simulate anything from mobile phones to bad radio reception on walkies and broken loudspeakers.</p>

<p>The StereoWidener, which decomposes a stereo input signal into mono and side components with variable delay and then recombines these to increase the perceived stereo effect.</p>

<figure>
<img src="../uploads/Main/AudioMixerStereoWidener.jpg" alt="A bunch of simple plug-ins without custom GUIs to get started with.">
<figcaption>A bunch of simple plug-ins without custom GUIs to get started with.</figcaption>
</figure>

<h2>Determine what plug-in to load on which platform?</h2>

<p>Native audio plug-ins use the same scheme as other native or <span class="tooltip"><strong>managed plug-ins</strong><span class="tooltiptext">A managed .NET assembly that is created with tools like Visual Studio for use in Unity. <a class="tooltipMoreInfoLink" href="Plugins.html">More info</a><br/><span class="tooltipGlossaryLink">See in <a class="tooltipMoreInfoLink" href="Glossary.html#Managedplug-in">Glossary</a></span></span></span>, in that, they must be associated with their respective platforms via the plug-in importer <span class="tooltip"><strong>inspector</strong><span class="tooltiptext">A Unity window that displays information about the currently selected GameObject, asset or project settings, allowing you to inspect and edit the values. <a href="UsingTheInspector.html">More info</a><br/><span class="tooltipGlossaryLink">See in <a href="Glossary.html#Inspector">Glossary</a></span></span></span>. For information about the subfolders and where to place plug-ins, refer to <a href="PluginsForDesktop.html">Building plug-ins for desktop platforms</a>. The platform association is necessary so that the system knows which plug-ins to include on a each build target in the standalone builds, and with the introduction of 64-bit support this even has to be specified within a platform. macOS plug-ins are useful because it supports universal binary format, which allows them to contain both 32 and 64 bit variants in the same bundle.</p>

<p>Native plug-ins in Unity that are called from managed code are loaded via the [DllImport] attribute, which reference the function to import from the native DLL. However, native audio plug-ins are different, because they need to be loaded before Unity starts creating any mixer assets that might need effects from the plug-in. The Editor doesn’t have this problem, because you can reload and rebuild the mixers that depend on plug-ins unlike in standalone builds, the plug-ins must be loaded before creating the mixer assets. To work around this, prefix the DLL of the plug-in <code>audioplugin</code> (case insensitive) for the system to detect and add it to a list of plug-ins that are automatically loaded at start. You must remember that the definitions inside the plug-in only define the names of the effects that are displayed inside Unity’s mixer. Regardless of what the <code>.dll</code> is called, it needs to start with the string <code>audioplugin</code> to be detected as such.</p>

<p>For platforms such as iOS, the plug-in code must be statically linked into the Unity binary that’s produced by the generated XCode project and just like plug-in rendering devices, the plug-in registration must be added explicitly to the startup code of the app.</p>

<figure>
<img src="../uploads/Main/AudioMixerPlugins.png" alt="">
</figure>

<p>On macOS, one bundle can contain both the 32 and 64 bit version of the plug-in. You can also split them to save size.</p>

<h3>Plug-ins with custom GUIs</h3>

<p>This section provides advanced plug-in use cases, such as effects for equalization and multiband <span class="tooltip"><strong>compression</strong><span class="tooltiptext">A method of storing data that reduces the amount of storage space it requires. See <a href="class-TextureImporterOverride.html">Texture Compression</a>, <a href="class-AnimationClip.html#AssetProperties">Animation Compression</a>, <a href="class-AudioClip.html">Audio Compression</a>, <a href="ReducingFilesize.html">Build Compression</a>.<br/><span class="tooltipGlossaryLink">See in <a href="Glossary.html#compression">Glossary</a></span></span></span>. These plug-ins have a much higher number of parameters than the simple plug-ins presented in the above section. In addition, the advanced plug-ins require physical coupling between parameters that require a better way to visualize the parameters than the simple sliders described above. Consider an equalizer for instance: each band has 3 different filters that collectively contribute to the final equalization curve and each of these filters has the 3 parameters frequency, Q-factor and gain which are physically linked and define the shape of each filter. It also useful to have an equalizer plug-in with a big display showing the resulting curve and the individual filter contributions. You operate the plug-in in such a way that multiple parameters are set simultaneously by simple dragging operations on the control instead of changing sliders one at a time.</p>

<figure>
<img src="../uploads/Main/AudioMixerCustomGUI.png" alt="">
</figure>

<p>For customizing the GUI of the Equalizer plug-in, drag the three bands to change the gains and frequencies of the filter curve. Hold shift down while dragging to change the shape of each band.</p>

<p>In summary, the definition, initialization, deinitialization, and parameter handling follows the exact same enum-based method that the simple plug-ins use, and even the <code>ProcessCallback</code> code is rather short. </p>

<p>To play around with a proper plug-in:
1. Open the <code>AudioPluginDemoGUI.sln</code> project in Visual Studio.
2. Locate the associated C# classes for the GUI code. </p>

<p>After Unity loads the native plug-in dlls and registers the contained audio plug-ins, it starts looking for corresponding GUIs that match the names of the registered plug-ins. This happens through the <strong>Name</strong> property of the EqualizerCustomGUI class which, like all custom plug-in GUIs, must inherit from <code>IAudioEffectPluginGUI</code>. The only important function inside this class is the bool <code>OnGUI(IAudioEffectPlugin plugin)</code> function. Through the <code>IAudioEffectPlugin</code> plug-in argument this function gets a handle to the native plug-in that it can use to read and write the parameters that the native plug-in has defined.</p>

<p>To read a parameter that the native plug-in calls:</p>

<pre><code>plugin.GetFloatParameter(&quot;MasterGain&quot;, out masterGain);
</code></pre>

<p>Which returns true if the parameter is found. To set it, it calls:</p>

<pre><code>plugin.SetFloatParameter(&quot;MasterGain&quot;, masterGain);
</code></pre>

<p>Which also returns true if the parameter exists, which is the most important binding between GUI and native code. </p>

<p>You can also use the function to query parameter NAME for its minimum, maximum, and default values to avoid duplicate definitions of these in the native and UI code.
<code>
plugin.GetFloatParameterInfo(&quot;NAME&quot;, out minVal, out maxVal, out defVal);
</code>
 If your OnGUI function returns true, the Inspector will display the default UI sliders below the custom GUI. This is useful for GUI development as all the parameters are available while developing your custom GUI with the added advantage to check that the right actions performed on it result in the expected parameter changes.</p>

<p>The DSP processing that goes on in the Equalizer and Multiband plug-ins are filters taken from Robert Bristow Johnson’s excellent Audio EQ Cookbook. You can use Unity’s internal API functions to plot the curves and draw antialiased curves for the frequency response.</p>

<p>Both Equalizer and Multiband plug-ins also provide code to overlay the input and output spectra for visualizing the effect of the plug-ins, which suggests: The GUI code runs at much lower update rate (the frame rate) than the audio processing and doesn’t have access to the audio streams. Therefore, to read this data, the native code provides the following special function:</p>

<pre><code>UNITY_AUDIODSP_RESULT UNITY_AUDIODSP_CALLBACK GetFloatParameterCallback(
    UnityAudioEffectState* state,
    int index,
    float* value,
    char *valuestr)
{
    EffectData::Data* data = &amp;state-&gt;GetEffectData&lt;EffectData&gt;()-&gt;data;
    if(index &gt;= P_NUM)
        return UNITY_AUDIODSP_ERR_UNSUPPORTED;
    if(value != NULL)
        *value = data-&gt;p[index];
    if(valuestr != NULL)
        valuestr[0] = 0;
  return UNITY_AUDIODSP_OK;
}
</code></pre>

<p>It enables reading an array of floating-point data from the native plug-in. The plug-in system doesn’t care about what that data is, as long as the request doesn’t slow down the UI or the native code. For the Equalizer and Multiband code, a utility class called <code>FFTAnalyzer</code> makes it easy to feed in input and output data from the plug-in and get a spectrum back. This spectrum data is then resampled by GetFloatBufferCallback and handed to the C# UI code. The data must be resampled so that the <code>FFTAnalyzer</code> runs the analysis at a fixed frequency resolution while <code>GetFloatBufferCallback</code> just returns the number of samples requested, which is determined by the width of the view that’s displaying the data. For a simple plug-in that has a minimal amount of DSP code you might want to use the CorrelationMeter plug-in, which plots the amplitude of the left channel against the amplitude of the right channel to display the stereo effects of the signal.</p>

<figure>
<img src="../uploads/Main/AudioMixerDemoCorrelationMeter.png" alt="">
</figure>

<figure>
<img src="../uploads/Main/AudioMixerDemoMultiband.jpg" alt="">
</figure>

<p>Left: Custom GUI of the CorrelationMeter plug-in.</p>

<p>Right: Equalizer GUI with overlaid spectrum analysis (green curve is source, red is processed).</p>

<p>At this point we would also like to point out that both the Equalizer and Multiband effects are kept intentionally simple and unoptimized, but we think they serve as good examples of more complex user interfaces that are supported by the plug-in system. There’s obviously a lot of work still in doing the relevant platform-specific optimizations, tons of parameter tweaking to make it fell really right and respond in the most musical way etc. etc… We might also implement some of these effects as built-in plug-ins in Unity at some point simply for the convenience of increasing Unity’s standard repertoire of plug-ins, but we sincerely hope that the reader will also take up the challenge to make some really awesome plug-ins – and who knows, they might at some point end up as built-in plug-ins. ;-)</p>

<figure>
<img src="../uploads/Main/AudioMixerDemoConvolutionReverb.png" alt="">
</figure>

<p>Convolution reverb example plug-in. The impulse response is decaying random noise,
defined by the parameters. This is only for demonstration purposes, as a production plug-in
should allow the user to load arbitrary recorded impulses, the underlying convolution algorithm
remains the same nevertheless.</p>

<figure>
<img src="../uploads/Main/AudioMixerDemoLoudnessMeter.png" alt="">
</figure>

<p>Example of a loudness monitoring tool measuring levels at 3 different time scales.
Also just for demonstration purposes, but a good place to start building a monitor tool that
conforms to modern loudness standardizations. The curve rendering code is built into Unity.</p>

<h3>Synchronizing to the DSP clock</h3>

<p>To try out some fun exercises, use the plug-in system to generate sound instead of processing it. For simple bassline and drum synthesizers for users who listen to acid trance, try simple clones of the main synths that defined this genre. <code>Plugin_TeeBee.cpp</code> and <code>Plugin_TeeDee.cpp</code> are simple synths that generate patterns with random notes, have parameters for tweaking the filters and envelopes in the synthesis engine. The state-&gt;dsptick parameter is read in the ProcessCallback to determine the position in a song. This counter is a global sample position, so you can divide it by the length of each note specified in samples and fire a note event to the synthesis engine whenever this division has a zero remainder. This way, all plug-in effects stay in sync to the same sample-based clock. If you want to play a prerecorded piece of music with a known tempo through such an effect, use the timing info to apply tempo-synchronized filter effects or delays on the music.</p>

<figure>
<img src="../uploads/Main/AudioMixerDemoTeeBee3o3.png" alt="">
</figure>

<figure>
<img src="../uploads/Main/AudioMixerDemoTeeDee9o9.png" alt="Simple bassline and drum synthesizers to demonstrate tempo-synchronized effects.">
<figcaption>Simple bassline and drum synthesizers to demonstrate tempo-synchronized effects.</figcaption>
</figure>

<h2>Spatialization</h2>

<p>The native audio plug-in SDK is the foundation of the Spatialization SDK, which allows developing custom spatialization effects to instantiate per <span class="tooltip"><strong>audio source</strong><span class="tooltiptext">A component which plays back an Audio Clip in the scene to an audio listener or through an audio mixer. <a class="tooltipMoreInfoLink" href="class-AudioSource.html">More info</a><br/><span class="tooltipGlossaryLink">See in <a href="Glossary.html#AudioSource">Glossary</a></span></span></span>.
For more information, see <a href="AudioSpatializerSDK.html">Audio Spatializer SDK</a>.</p>

<h2>Outlook</h2>

<p>This is just the beginning of an effort to open up parts of the sound system to high performance native code. Future plans include:</p>

<ul>
<li>Integrate native audio in other parts of Unity and utilize the effects outside the mixer.</li>
<li>Extend the SDK to support other parameter types than floats with support for better default GUIs and storage of binary data.</li>
</ul>

<p><strong>Disclaimer:</strong></p>

<p>While there are many similarities in the design, Unity’s native audio SDK isn’t built on top of other plug-in SDKs like Steinberg VST or Apple AudioUnits. While it’s possible to implement basic wrappers for these using this SDK that allow using such plug-ins with Unity, it’s important to note that this is strictly not managed by the Unity development team.
<br> Hosting a plug-in poses its own challenges. For example, dealing with the intricacies of expected invocation orders and handling custom GUI windows that are based on native code can quickly become unmanageable, making the example code unhelpful.</p>

<p>While it’s possible to load your VST or AU plug-in or even effects for mocking up and testing sound design, note that using VST/AU limits you to few specific platforms. The advantage of writing audio plug-ins based on the Unity SDK however, is that it allows you to extend it to all platforms that support software-mixing and dynamically loaded native code. Therefore, use this approach only if you want to make a nice solution for mocking up early sound design with your favorite tools before committing to dedicating time to develop custom plug-ins (or simply to use metering plug-ins in the Editor that don’t alter the sound in any way).</p>

<hr>
<!-- area:authoring -->
<div id="_content"></div>
<div class="nextprev clear">
<div class="icon tt left mr1" data-distance="-40|-30|top">
<span class="prev"><a href="AudioMixerUsage.html"></a></span><div class="tip">Overview of Usage and API</div>
</div>
<div class="icon tt right" data-distance="-40|-30|top">
<span class="next"><a href="AudioSpatializerSDK.html"></a></span><div class="tip"> Audio Spatializer SDK</div>
</div>
</div>
</div>
<div class="footer-wrapper"><div class="footer clear">
<div class="copy">Copyright © 2023 Unity Technologies. Publication Date: 2023-09-25.</div>
<div class="menu">
<a href="https://learn.unity.com/">Tutorials</a><a href="https://answers.unity3d.com">Community Answers</a><a href="https://support.unity3d.com/hc/en-us">Knowledge Base</a><a href="https://forum.unity3d.com">Forums</a><a href="https://unity3d.com/asset-store">Asset Store</a><a href="https://docs.unity3d.com/Manual/TermsOfUse.html">Terms of use</a>
</div>
</div></div>
</div></div></div>
</div>
</body>
</html>
